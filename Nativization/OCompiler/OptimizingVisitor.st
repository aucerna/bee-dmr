"
	Copyright (c) 2020-2022 Quorum Software.
	See (MIT) license in root directory.
"

Class {
	#name : #OptimizingVisitor,
	#superclass : #ParseTreeVisitor,
	#instVars : [
		'method',
		'firstBlock',
		'currentBlock',
		'locals',
		'abi',
		'sendInliner',
		'activation'
	],
	#category : #OCompiler
}

{ #category : #'emitting - load' }
OptimizingVisitor >> activation [
	^activation
]

{ #category : #'emitting - load' }
OptimizingVisitor >> allActivations [
	^firstBlock nodesSelect: [:node | node class == OActivationContext]
]

{ #category : #private }
OptimizingVisitor >> defineActivationRecord [
	activation := OActivationContext named: #activationRecord.
	activation temporaries: method tempCount.
	currentBlock add: activation
]

{ #category : #private }
OptimizingVisitor >> defineSelf [
	| definition |
	definition := OLoadImplicit named: #self.
	currentBlock add: definition
]

{ #category : #accessing }
OptimizingVisitor >> environment: aNativizationEnvironment [
	abi := aNativizationEnvironment abi
]

{ #category : #initialization }
OptimizingVisitor >> initialize [
	firstBlock := OBasicBlock new.
	currentBlock := firstBlock.
	locals := OrderedCollection new
]

{ #category : #private }
OptimizingVisitor >> insertReturnSelf [
	| instruction |
	instruction := OReturn new source: activation receiver; frame: activation.
	currentBlock add: instruction.
	^instruction
]

{ #category : #'emitting - load' }
OptimizingVisitor >> loadArgument: index [
	| offset load |
	offset := method argumentCount - index + 3.
	load := OLoadOperation base: self activation slotAtImm: offset.
	^currentBlock add: load
]

{ #category : #'emitting - load' }
OptimizingVisitor >> loadAssociation: anAssociation [
	| global read name |
	name := anAssociation key asString asSymbol.
	name == #WordSize ifTrue: [^self loadLiteral: abi wordSize].
	name == #WordSizeShift ifTrue: [^self loadLiteral: abi wordSizeShift].
	global := OLoadConstant valued: anAssociation.
	read := OLoadOperation base: global slotAtImm: 1.
	currentBlock add: global; add: read.
	^read
]

{ #category : #'emitting - load' }
OptimizingVisitor >> loadEnvironment: envIndex [
	| result |
	result := self activation environment.
	envIndex ifNotNil: [
		result := OLoadOperation base: result slotAtImm: envIndex.
		currentBlock add: result].
	^result
]

{ #category : #'emitting - load' }
OptimizingVisitor >> loadEnvironmentTemporary: tempIndex environment: envIndex [
	| load environment |
	self error: 'non-inlined closure arguments not yet supported'.
	environment := self loadEnvironment: envIndex.
	load := OLoadOperation base: environment slotAtImm: tempIndex.
	currentBlock add: load.
	^load
]

{ #category : #'emitting - load' }
OptimizingVisitor >> loadFalse [
	^self loadLiteral: false
]

{ #category : #'emitting - load' }
OptimizingVisitor >> loadInstance: index [
	| receiver load |
	receiver := self activation receiver.
	load := OLoadOperation base: receiver slotAtImm: index.
	currentBlock add: load.
	^load
]

{ #category : #'emitting - load' }
OptimizingVisitor >> loadLiteral: value [
	| constant |
	constant := OLoadConstant valued: value.
	currentBlock add: constant.
	^constant
]

{ #category : #'emitting - load' }
OptimizingVisitor >> loadNil [
	^self loadLiteral: nil
]

{ #category : #'emitting - load' }
OptimizingVisitor >> loadSelf [
	^self activation receiver
]

{ #category : #'emitting - load' }
OptimizingVisitor >> loadTemporary: anInteger [
	| index load |
	index := -1 - anInteger.
	load := OLoadOperation base: self activation slotAtImm: index.
	currentBlock add: load.
	^load
]

{ #category : #'emitting - load' }
OptimizingVisitor >> loadTrue [
	^self loadLiteral: true
]

{ #category : #private }
OptimizingVisitor >> lowerSpecialABI: aMethodNode [
	| literals i actual next load names |
	literals := method literals.
	literals size = 0 ifTrue: [^self].
	(literals at: 1) == #savePreviousSelf ifTrue: [
		activation doSavePreviousSelf.
		load := firstBlock detect: [:inst | inst isConstant].
		load dissolve.
		literals := literals copyFrom: 2].
	literals size = 0 ifTrue: [^self].
	(literals at: 1) == #specialABIBegin ifFalse: [^self].
	i := 2.
	names := aMethodNode arguments collect: [:arg | arg name asSymbol].
	[(literals at: i) == #specialABIEnd]
		whileFalse: [| name register implicit regname index offset |
			name := literals at: i.
			regname := literals at: i + 1.
			register := self registerNamed: regname.
			name = #self ifTrue: [activation receiver register: register] ifFalse: [
				index := names indexOf: name.
				offset := method argumentCount - index + 3.
				self allActivations do: [:frame | 
					implicit := (OLoadImplicit named: name) register: register.
					frame receiver afterInsert: implicit.
					frame arguments
						select: [:arg | arg index == offset]
						thenDo: [:arg | arg replaceAllUsesWith: implicit; dissolve]]].
			i := i + 2].
	actual := firstBlock detect: [:inst | inst isConstant].
	[
		next := actual next.
		actual dissolve.
		actual isConstant and: [actual value == #specialABIEnd]]
		whileFalse: [actual := next]
]

{ #category : #accessing }
OptimizingVisitor >> method: aCompiledMethod [
	method := aCompiledMethod
]

{ #category : #inquiries }
OptimizingVisitor >> registerNamed: regname [
	^abi perform: regname
]

{ #category : #'emitting - store' }
OptimizingVisitor >> storeAssociation: association with: value [
	| global write |
	global := OLoadConstant valued: association.
	write := OStoreOperation base: global slotAtImm: 1 put: value.
	currentBlock add: global; add: write
]

{ #category : #'emitting - store' }
OptimizingVisitor >> storeEnvironmentTemporary: tempIndex environment: envIndex with: value [
	| environment store |
	self error: 'non-inlined closure arguments not yet supported'.
	environment := self loadEnvironment: envIndex.
	store := OStoreOperation base: environment slotAtImm: tempIndex put: value.
	currentBlock add: store
]

{ #category : #'emitting - store' }
OptimizingVisitor >> storeInstance: index with: value [
	| write |
	write := OStoreOperation
		base: self activation receiver
		slotAtImm: index
		put: value.
	currentBlock add: write
]

{ #category : #'emitting - store' }
OptimizingVisitor >> storeTemporary: anInteger with: value [
	| store index |
	index := -1 - anInteger.
	store := OStoreOperation base: self activation slotAtImm: index put: value.
	currentBlock add: store
]

{ #category : #visiting }
OptimizingVisitor >> visit: aParseNode [
	super visit: aParseNode.
	^firstBlock
]

{ #category : #visiting }
OptimizingVisitor >> visitAssignment: anAssignmentNode [
	| result |
	result := anAssignmentNode expression acceptVisitor: self.
	anAssignmentNode assignees
		do: [:node | node binding store: result using: self]
]

{ #category : #visiting }
OptimizingVisitor >> visitBlock: aBlockNode [
	| previous cfg |
	previous := currentBlock.
	cfg := OBasicBlock new.
	currentBlock := cfg.
	self visitScript: aBlockNode.
	currentBlock := previous.
	^OBlockClosure containing: cfg
]

{ #category : #visiting }
OptimizingVisitor >> visitCascade: aCascadeNode [
	| receiver arguments send block |
	block := currentBlock.
	receiver := aCascadeNode receiver acceptVisitor: self.
	aCascadeNode messages do: [:msg | 
		arguments := msg arguments collect: [:node | node acceptVisitor: self].
		send := OMessageSend
			receiver: receiver
			selector: msg selector value asSymbol
			arguments: arguments.
		block add: send].
	^send
]

{ #category : #visiting }
OptimizingVisitor >> visitIdentifier: anIdentifierNode [
	^anIdentifierNode binding loadUsing: self
]

{ #category : #visiting }
OptimizingVisitor >> visitLiteral: aLiteralNode [
	| load |
	load := OLoadConstant valued: aLiteralNode value.
	currentBlock add: load.
	^load
]

{ #category : #visiting }
OptimizingVisitor >> visitMessage: aMessageNode [
	| receiver arguments selector send |
	receiver := aMessageNode receiver acceptVisitor: self.
	arguments := aMessageNode arguments
		collect: [:node | node acceptVisitor: self].
	selector := aMessageNode selector symbol.
	send := OMessageSend
		receiver: receiver
		selector: selector
		arguments: arguments.
	currentBlock add: send.
	^send
]

{ #category : #visiting }
OptimizingVisitor >> visitMethod: anSMethod [
	| last |
	self visitScript: anSMethod.
	last := currentBlock lastValue.
	last isReturn ifFalse: [self insertReturnSelf].
	self lowerSpecialABI: anSMethod
]

{ #category : #visiting }
OptimizingVisitor >> visitReturn: aReturnNode [
	| source instruction |
	source := aReturnNode expression acceptVisitor: self.
	instruction := OReturn new source: source; frame: activation.
	currentBlock add: instruction.
	^instruction
]

{ #category : #visiting }
OptimizingVisitor >> visitScript: aScriptNode [
	| previous |
	previous := activation.
	self defineActivationRecord; defineSelf.
	aScriptNode statements do: [:node | node acceptVisitor: self].
	previous ifNotNil: [activation := previous]
]

{ #category : #visiting }
OptimizingVisitor >> visitSelector: aSelectorNode [
	
]

